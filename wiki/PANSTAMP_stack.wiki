#labels panstamp,arduino,library
*The stack, the core of the panStamps*

= Introduction =

The panStamp stack is the firmware behind the scenes. It's primarily formed by a public set of functions, variables and, the most important, all the automatic procedures that deal with the SWAP protocol.

= Functionality =

The stack is responsible of doing the following tasks:

 * Listening to the wireless SWAP network
 * Parsing incoming SWAP packets
 * Transmission of SWAP packets
 * Automatic generation of responses to incoming SWAP commands and queries
 * Management of registers, including updates and external control
 * Control of the internal state machine
 * Power management
 * Storage of configuration registers in EEPROM

All the above features provide a high degree of isolation between network communications, endpoint management and user code. In fact, the main goal of using this stack is letting the user concentrate on developing the application whilst the stack does the rest.

<p align="center">https://lh6.googleusercontent.com/-9pPNOkG2-Os/ThCPlE7RceI/AAAAAAAAA9s/vZb_3ZX4GiM/stack_3.png</p>


= How it works =

Stack and application run on a single-thread. Through the use of interruptions, the stack receives and parses wireless packets without interfering the normal operation of the user application. The CC1101 IC does an address check on each packet received. Thus, only packets addressed to our device are passed to the stack. Whenever a SWAP packet is received, the following mechanisms come into play:

*1. SWAP query addressed to our device*
The panStamp stack looks up the table of registers and responds with an info packet.

*2. SWAP command addressed to our device*
The panStamp stack looks up the table of registers, runs register's setter function (if exists) and responds with an info packet

*3. SWAP info packet broadcasted*
The panStamp stack calls a user callback function so that the info packet can be dispatched from the Arduino sketch.

With the above automatic procedures, a good degree of abstraction between stack and user application is achieved. At the same time, user application is freed from having to deal with SWAP-related details. Which is the magics behind all this?

In order to make this engine work, developers have to build a table of registers for each device (each sketch). The first part of the table is common to all devices, formed by some standard registers as _channel number_, _address_ or _network id_. The rest of registers are proprietary to each application.


= Table of registers =

_regTable_ is the global table of registers. Each member of this table (REGISTER) has to be created using the following constructor:

{{{
    /**
     * REGISTER
     * 
     * Constructor
     * 
     * 'val'          Pointer to the register value
     * 'len'          Length of the register value
     * 'getValH'      Pointer to the getter function
     * 'setValH'      Pointer to the setter function
     */
    REGISTER(byte *val, const byte len, const void (*updateValH)(byte rId), const void (*setValH)(byte rId, byte *v)):id(regIndex++), value(val), length(len), updateValue(updateValH), setValue(setValH) {};
}}}